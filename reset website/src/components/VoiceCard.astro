---
const {
  category,
  text
} = Astro.props

---

<div class="voice_card">
    <h3>
      <slot name="category" />
    </h3>
  <div>
    <slot name="text" />
  </div>
</div>

<style>
  .voice_card {
    box-sizing: border-box;
    width: auto;
    border: 1px solid #ECECEC ;
    border-radius: 8px;
    background-color: #FAFAFA;
    padding: 1.6rem;
    margin: 4rem auto;
    box-shadow: 2px 2px 10px 0px rgba(0, 0, 0, 0.20);
    max-width: 435px;
    opacity: 0;
    transform: translateY(20px);
    transition: all 2s;
  }

  h3 {
    font-size: 1.8rem;
    margin-bottom: 1.6rem;
  }

  @media screen and ( 768px <= width ) {
    .voice_card {
      width: 46%;
      margin: 0 auto;
    }
    .voice_card:nth-child(2n+1){
      margin: 1rem auto 1rem 2.4rem ;
    }
    .voice_card:nth-child(2n){
      margin: 1rem 2.4rem 1rem auto ;
    }
    .voice_card:not(:first-child) {
      margin-top: -7%;
    }

  }

</style>


<script>
  document.addEventListener("DOMContentLoaded", function () {
     class ScrollObserver {
       constructor(els, cb, options) {
         //監視対象のelementsを取得
         this.els = document.querySelectorAll(els);
         //オプションのデフォルト設定を定義
         const defaultOptions = {
           root: null,
           rootMargin: "0px",
           threshold: 0,
         };
         this.cb = cb;
         //デフォルト設定に、個別設定のオプションをマージする
         this.options = Object.assign(defaultOptions, options);
         //
         this._init();
       }
       _init() {
         const callback = (entries) => {
           entries.forEach((entry) => {
             //監視対象の要素が領域内に入った場合の処理
             if (entry.isIntersecting) {
               this.cb(entry.target, true); //true=isIntersectingがtrue
               //処理後に監視を切る処理
               observer.unobserve(entry.target);
             }
           });
         };
         const observer = new IntersectionObserver(
           callback.bind(this),
           this.options
         );
         //対象の要素elを監視
         this.els.forEach((el) => observer.observe(el));
       }
     }

     const fadein = function (el, isIntersecting) {
       if (isIntersecting) {
         el.style.opacity = 1;
         el.style.transform = "none";
       }
     };
     const fadeinTrigger = new ScrollObserver(".voice_card", fadein, {
       rootMargin: "-200px 0px",
       threshold: 0,
     });
   });

 </script>
